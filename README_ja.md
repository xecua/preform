# preform
リポジトリマイニング向けにgitリポジトリの前処理を行うツールです．
マイニングツールへの/からの依存をなくすために極力このツールだけで完結するようにしています．
このため，処理が不十分，まったく役に立たないといったことも起こり得ます．

このツールが処理するデータは文献で処理した方が良いと記載されていたものを含みます．
この場合の具体的な文献は各処理の説明で言及します．

## 用法
Java開発環境(JDK)が必要となります．

実行方法は現時点で以下の2つがあります．

+ gradleタスクとして実行
    ```shell
    ./gradlew run --args="[options] <source> <target> <Filters>..."
    ```
+  実行可能jarから実行
    ```shell
    ./gradlew shadowJar
    java -jar build/libs/preform-all.jar [options] <source> <target> <Filters>...
    ```

引数は以下の通りです(`--help`オプションからも参照できます)．
+ `<source>`: 前処理を施したいリポジトリのパスです．
+ `<target>`: 前処理後のリポジトリを出力するパスです．処理を複数指定し，かつ`--save`オプションを有効にした場合，これは中間生成リポジトリが格納されるディレクトリとなります．
+ `<Filters>`: 処理を指定します．複数指定もできます(指定順に処理が行われます)．

オプションは以下の通りです．
+ `--bare`: `<source>`がbareリポジトリである場合に指定してください．これが何かわからなければつける必要はないはずです．
+ `--clean`: `<target>`を再帰的に削除してから処理を開始します．
+ `-d`, `--duplicate`: 出力リポジトリ上に入力リポジトリのデータがコピーされます．
+ `-s`, `--save`: 複数の処理を指定した場合に，各処理後のリポジトリを保存するようにします(通常は`$TMP`に格納します．ここに保存したデータはデバイスの電源を切断するとデータが失われる可能性があります)．このオプションを指定した場合，`<target>`は出力されたリポジトリそのものではなく，各処理後のリポジトリ(中間生成リポジトリ)が含まれるディレクトリとなります．中間生成リポジトリの名前はそれまでに行われた処理の名前をハイフン区切りでつなげたものになります．

---

出力されたリポジトリではコミットIDが変化しています．
GitHub上のデータを参照したい場合などに入力リポジトリにおけるIDを追跡できるよう，出力リポジトリの各コミットには`git-notes(1)`の仕組みで入力リポジトリのコミットIDの情報が付与されます．

## 処理(サブコマンド)

文献に記載されていたもののうち，このツールで完結させることが難しいものは，コミットメッセージに対して注釈を付与するという処理を行います．
この注釈には冒頭に必ず`[Preform]`というprefixをつけているため，この文字列が存在するコミットは注釈がついているという判断ができます(もともとつけられていたコミットメッセージ．

+ `PassThrough`: 何もしません(`<target>`に`<source>`がコピーされるような挙動になります)．動作チェックにお使い下さい．
+ `LinebreakNormalizer`: 各スナップショットの全ファイルの改行コードを統一します．
  + `--to`オプションが存在します．ここで指定した改行コードに統一できます(`LF`，`CR`，`CRLF`が指定可能です．デフォルトは`LF`です）．
+ `Format`: 各スナップショットの全Javaソースコードに同一の基準によるフォーマッタを適用します．これによりホワイトスペース関連の変更が抑えられます[^1]．
+ `CommentRemover`: 各スナップショットの全Javaソースコードからコメントを除去します[^1]．
+ `LocalVariableInliner`: 各スナップショットの全Javaソースコードに対し，直後の文でしか使用されていない変数をインライン化することにより，この変数に関連した変更を抑制します(再帰的には行われません)[^1]．
+ `TrivialKeywordNormalizer`: 各スナップショットの全Javaソースコードに対し，Javaのキーワードに関する一部の変更を抑制します．具体的な処理内容は次の通りです[^1]
  + メソッド内において，そのクラスのフィールドであると判断できる変数すべてに`this.`というレシーバを付与します．これによりこの`this`の挿入/削除に関する変更が抑制されます．
  + デフォルトコンストラクタ中に親クラスのデフォルトコンストラクタを呼ぶ`super()`が存在した場合，これを削除します．
  + `void`メソッドの最後の文に`return`があった場合，これを削除します．
+ `RevertCommitSquasher`: 連続した2コミットがrevert-被revertの関係にある時，この2つのコミットを履歴から消去します(再帰的には行われません．すなわち，消去後に連続した2コミットがrevert-被revertの関係にあっても，このペアは消去されません．この挙動は変わる可能性があります)[^2]．
  + Revertコミットであるかどうかは「revertコミットが`git-revert(1)`のデフォルトのメッセージである」「一方の変更が他方の変更と逆の変更を行っている」のいずれかを満たすかどうかによって判定します(文献[^2]と同様の方法です)．

+ `RevertCommitMarker`: `RevertCommitSquasher`と同様の判定条件によりrevert-被revertの関係にあると判断された2コミットに対し，それらがrevertしている・されているコミットであることを示す注釈を付与します．だたし，こちらは非連続なコミット対に対しても条件判定を行うため，`Squasher`よりも多くのコミット対を捕捉できる可能性があります[^2]．
+ `QuickRemedyMarker`: 文献[^2]において"Quick Remedy Commit"と名付けられている，「同一Authorによる」「直前のコミットから5分以内にコミットされた」「メッセージに特定の単語を含んでいる」の3条件を満たすコミットに注釈を付与します．
+ `NonEssentialDiffMarker`: 文献[^1]において"Non Essential"であると名付けられている変更を含むコミットに対し，その旨を記載した注釈を付与します．
  + この"Non Essential"な変更には`Format`/`CommentRemover`/`LocalvariableInliner`/`TrivialKeywordNormalizer`で抑制した変更も含まれますが，現時点ではこの`Marker`はこれらの変更(のみ)を含むコミットには注釈を付与しません．
    文献[^1]で指摘されているものの上記のような方法で対処できないと判断した，「ローカル変数の名前変更」「フィールドの名前変更」を含むコミットに対してのみ注釈が付与されます．


[^1]: D. Kawrykow and M. P. Robillard, “Non-essential changes in version histories,” in Proceedings of the 33rd International Conference on Software Engineering, 2011, pp. 351–360. doi: 10.1145/1985793.1985842.
[^2]: F. Wen, C. Nagy, M. Lanza, and G. Bavota, “Quick remedy commits and their impact on mining software repositories,” Empir. Softw. Eng., vol. 27, no. 1, pp. 1–14, 2022, doi: 10.1007/s10664-021-10051-z.
